import randomimport timeimport copyimport numpy as npimport paramimport utilNUM_ACTIONS = 200SMALL = 1BIG = 2TRIPLE_ONE = 211TRIPLE_TWO = 212TRIPLE_THREE = 213TRIPLE_FOUR = 214TRIPLE_FIVE = 215TRIPLE_SIX = 216def DEFAULT_TRANSFORM(stat, choice, amount):	assert 0 < amount <= stat.balance()	random.seed(time.time())	# Three dices gives permutation of 6 * 6 * 6	r = random.randint(1, 216)	# [0, 105] stands for small and [106, 210] stands for BIG,	# and [211, 216] stands for triple_***	if (r <= 105 and choice == SMALL) or (106 <= r <= 210 and choice == BIG):		# gambler wins		stat.update(amount)	elif choice == r >= 211:		# gambler wins (149+1) times of money		stat.update(amount * 149)	else:		stat.update(-amount)class State:	# The value of "balance" and "goal" should be normalized to the percentage of	# the original total jettons, which is in the domain of (0, 1]	def __init__(self, step, balance, goal):		self._value = [step, balance, goal]	def value(self):		return np.asarray(self._value)	def tuple_value(self):		return tuple(self._value)	def step(self):		return self._value[0]	def balance(self):		return self._value[1]	def goal(self):		return self._value[2]	def transform(self, f, choice, amount):		f(self, choice, amount)	def update(self, amount):		self._value[0] += 1		self._value[1] += amount	# @in: choice and value is a tuple of (choice, value)	# @ret: the copied transformed state.	def copy_transform(self, f, choice_value):		choice, value = choice_value		c = copy.deepcopy(self)		c.transform(f, choice, value)		return c	def available_actions(self):		actions = []		balance = min(100, self.balance())		for c in [SMALL, TRIPLE_ONE]:			for i in range(param.ACTION_INTERVAL, balance + param.ACTION_INTERVAL, param.ACTION_INTERVAL):				# 0 < a <= 1 stands for the choice of SMALL/BIG with value a				# a > 1 for TRIPLE with value a - 1				a = util.action_from_choice_value(c, i)				actions.append(a)		return actions	def __eq__(self, other):		return self.value() == other.value()	def __ne__(self, other):		return self.value() != other.value()	def __hash__(self):		return hash(tuple(self._value))if __name__ == "__main__":	stat = State(0, 100, 10)	stats = set()	stats.add(stat)	stat2 = State(0, 100, 10)	if stat2 in stats:		print(hash(stat2))	l = list()	l.append(stat)	stat.update(-10)	l.append(stat)	assert l[0] == l[1]	print(l[0].balance(), l[1].balance())	stat_copy = copy.deepcopy(stat)	stat_copy.update(50)	l.append(stat_copy)	print(l[0].balance(), l[2].balance())	assert l[0].balance() != l[2].balance()	stat.transform(DEFAULT_TRANSFORM, SMALL, 1)	print(stat.balance())